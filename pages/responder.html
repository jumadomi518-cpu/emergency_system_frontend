<!DOCTYPE html>
<html>
<head>
  <title>Emergency Response Dashboard</title>
  <meta charset="UTF-8" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <style>
    
 * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box; 
      font-family: "Poppins",sans-serif;
    }
  
    h2 { 
      text-align: center; 
  
      padding: 0.5em;
      background-color: whitesmoke;
    }

     
    
    #map { 
      height: 400px; 
      margin-bottom: 10px; 
    }
    table { 
      width: 100%; 
      border-collapse: collapse; 
    }
    
    .table {
      padding: 0.5em;
    }
    th,td { 
      border: 1px solid #ccc; 
      padding: 6px; 
      text-align: center; 
    }
    button { 
      font-size: 1.1rem;
      padding: 5px 8px; 
      border: none; 
      border-radius: 4px; 
      cursor: pointer; 
      width: 20%;
      background-color: magenta;
      color: white;
    }
    .accept { 
      background: green; 
      color: white;
    }
    .reject { 
      background: red; 
      color: white;
    }
    .resolve { 
      background: purple; 
      color: white;
    }
    .routeOption { 
      background: #007bff; 
      color: white; 
      margin: 2px;
    }
    #routeInfo { 
      margin-top: 8px; 
      font-size: 14px; 
    }
    #debugPanel {
      position:fixed; bottom:0; left:0; width:100%;
      max-height:150px; overflow-y:auto;
      background:rgba(0,0,0,0.8); color:#0f0;
      font-size:11px; padding:5px; font-family:monospace;
    }
.routeCard {
  border: 1px solid #ddd;
  padding: 10px;
  margin-bottom: 8px;
  border-radius: 6px;
  background: #fff;
}

.routeCard span {
  display: inline-block;
  margin-right: 10px;
  font-size: 14px;
}

.routeCard button {
  float: right;
  padding: 4px 10px;
  border: none;
  background: #1976d2;
  color: white;
  border-radius: 4px;
  cursor: pointer;
}

.routeCard.selected {
  border: 2px solid #1976d2;
  background: #e3f2fd;
}
  </style>
</head>
<body>

<h2>Emergency Response Dashboard</h2>
<div class="table">
<table>
<thead>
<tr><th>Name</th><th>Phone</th><th>Message</th><th>Action</th><th>waiting</th></tr>
</thead>
<tbody id="rows"></tbody>
</table>
</div>
<div id="routeInfo">
</div>
<div id="map"></div>

<div id="debugPanel"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
// DEBUG LOG
function log(msg){
  const panel = document.getElementById("debugPanel");
  const time = new Date().toLocaleTimeString();
  panel.innerText += `[${time}] ${typeof msg==="object"?JSON.stringify(msg):msg}\n`;
  panel.scrollTop = panel.scrollHeight;
}


if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("/swr.js")
    .then(() => log("SW registered"))
    .catch(err => log("SW registration failed: " + err));
}

// CONFIG
const WS_URL = "wss://campus-emergency-server.onrender.com";
const role = localStorage.getItem("role");
let ws;
let activeAssignment = null;


// MAP
const map = L.map("map").setView([0,0],2);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(map);

const emergencyMarkers = {};
const responderMarkers = {};
const routeLines = {};
let currentWatchId = null;


// RESPONDER ICON
const responderIcon = L.icon({
  iconUrl: 'https://cdn-icons-png.flaticon.com/512/684/684908.png', // your original arrow
  iconSize: [30, 30],       // size of the arrow
  iconAnchor: [15, 15]      // center of rotation
});


// CONNECT WEBSOCKET
function connectWS(){
  ws = new WebSocket(WS_URL);

  ws.onopen = () => {
    const token = localStorage.getItem("token");
    if(token) ws.send(JSON.stringify({ token }));
    log("WS Connected");
    log("Role: " + role);
  };

  ws.onclose = ()=>{
    log("WS Reconnecting...");
    setTimeout(connectWS,3000);
  };

  ws.onmessage = handleWSMessage;
}
connectWS();

// HANDLE MESSAGES
function handleWSMessage(e){
  const msg = JSON.parse(e.data);
  log(msg);

  // After authentication â†’ send initial location
  if (msg.type === "AUTH_SUCCESS") {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(pos => {
        ws.send(JSON.stringify({
          type: "LOCATION_UPDATE",
          latitude: pos.coords.latitude,
          longitude: pos.coords.longitude
        }));
      }, console.error, { enableHighAccuracy: true });
    }
  }

  // Only responders handle assignments
  if(msg.type === "EMERGENCY_ASSIGNMENT" && role !== "user"){
    showAssignmentUI(msg);
    log("Emergency Assignment received " + msg);
  }

  // If victim gets responder accepted
  if(msg.type === "RESPONDER_ACCEPTED"){
    log("Responder accepted alert " + msg.alertId);
  }

  if(msg.type === "ALERT_RESOLVED"){
    removeAlert(msg.alertId);
  }
}


// SHOW ASSIGNMENT UI
function showAssignmentUI(msg){

  activeAssignment = msg;

  // Add marker for emergency
  if(!emergencyMarkers[msg.alertId]){
    emergencyMarkers[msg.alertId] =
      L.marker([msg.latitude,msg.longitude]).addTo(map);
  }

  const row = document.createElement("tr");
  row.innerHTML = `
    <td>${msg.name || "Unknown"}</td>
    <td>${msg.phone || "Unknown"}</td>
    <td>${msg.message}</td>
    <td class="status">
      <button onclick="respondToAssignment(${msg.alertId}, true)">Accept</button>
      <button onclick="respondToAssignment(${msg.alertId}, false)">Reject</button>
    </td>
  `;

  document.getElementById("rows").appendChild(row);
}

// RESPOND TO ASSIGNMENT
function respondToAssignment(alertId, accept){
  const status = document.querySelector(".status");
  ws.send(JSON.stringify({
    type:"RESPONDER_RESPONSE",
    alertId,
    accept
  }));

  if(accept && activeAssignment){
 
  status.innerText = "Accepted";
    startNavigation(
      alertId,
      activeAssignment.latitude,
      activeAssignment.longitude
    );
  } else {
 status.innerText = "rejected";
  }
}


// START NAVIGATION
function startNavigation(alertId, destLat, destLng){

  if(currentWatchId) navigator.geolocation.clearWatch(currentWatchId);

  if(!responderMarkers[alertId]){
    responderMarkers[alertId] =
      L.marker([0,0],{icon:responderIcon}).addTo(map);
  }

  navigator.geolocation.getCurrentPosition(pos => {

  const startLat = pos.coords.latitude;
  const startLng = pos.coords.longitude;

  responderMarkers[alertId].setLatLng([startLat,startLng]);

  fetchRoutes(alertId,startLat,startLng,destLat,destLng);

});


  currentWatchId = navigator.geolocation.watchPosition(pos=>{

    const startLat = pos.coords.latitude;
    const startLng = pos.coords.longitude;

    responderMarkers[alertId].setLatLng([startLat,startLng]);

    updateHeading();

    ws.send(JSON.stringify({
      type:"LOCATION_UPDATE",
      alertId,
      latitude:startLat,
      longitude:startLng
    }));

  }, console.error, { enableHighAccuracy:true });
}


function fetchRoutes(alertId, sLat, sLng, dLat, dLng) {

  fetch(`https://router.project-osrm.org/route/v1/driving/${sLng},${sLat};${dLng},${dLat}?alternatives=true&overview=full&geometries=geojson`)
  .then(r => r.json())
  .then(data => {

    if (!data.routes || data.routes.length === 0) return;

    const routeDiv = document.getElementById("routeInfo");
    routeDiv.innerHTML = "";

    // Clear old routes
    if (!routeLines[alertId]) routeLines[alertId] = [];
    routeLines[alertId].forEach(line => map.removeLayer(line));
    routeLines[alertId] = [];

    const colors = ["blue", "green", "red", "orange", "purple"];

    // Find best route (shortest distance + shortest duration)
    let bestIndex = 0;
    let bestScore = Infinity;

    data.routes.forEach((route, index) => {
      const score = route.distance + route.duration;
      if (score < bestScore) {
        bestScore = score;
        bestIndex = index;
      }
    });

    data.routes.forEach((route, index) => {

      const coords = route.geometry.coordinates.map(c => [c[1], c[0]]);
      const distance = (route.distance / 1000).toFixed(2);
      const duration = (route.duration / 60).toFixed(1);

      // Draw ALL routes
      const polyline = L.polyline(coords, {
        color: colors[index % colors.length],
        weight: index === bestIndex ? 6 : 4,
        opacity: index === bestIndex ? 1 : 0.6
      }).addTo(map);

      routeLines[alertId].push(polyline);

      // Create route card
      const card = document.createElement("div");
      card.className = "routeCard";

      const routeName = document.createElement("h4");
      routeName.innerText = `Route ${String.fromCharCode(65 + index)}`;

      const distanceSpan = document.createElement("span");
      distanceSpan.innerText = `Distance: ${distance} km`;

      const durationSpan = document.createElement("span");
      durationSpan.innerText = `Duration: ${duration} min`;

      const btn = document.createElement("button");
      btn.innerText = index === bestIndex ? "Preferred" : "Use";

      if (index === bestIndex) {
        card.classList.add("selected");
      }

      btn.onclick = () => {

        // Update UI highlight
        document.querySelectorAll(".routeCard").forEach(c => {
          c.classList.remove("selected");
          c.querySelector("button").innerText = "Use";
        });

        card.classList.add("selected");
        btn.innerText = "Selected";

        // Highlight selected route
        routeLines[alertId].forEach((line, i) => {
          line.setStyle({
            weight: i === index ? 6 : 4,
            opacity: i === index ? 1 : 0.6
          });
        });

        map.fitBounds(polyline.getBounds());

        // Send FULL route coordinates to server
        ws.send(JSON.stringify({
          type: "SELECTED_ROUTE",
          alertId,
          routeIndex: index,
          distance,
          duration,
          routeCoordinates: coords
        }));
      };

      card.appendChild(routeName);
      card.appendChild(distanceSpan);
      card.appendChild(document.createElement("br"));
      card.appendChild(durationSpan);
      card.appendChild(document.createElement("br"));
      card.appendChild(btn);

      routeDiv.appendChild(card);

      // AUTO SEND BEST ROUTE TO SERVER
      if (index === bestIndex) {
        ws.send(JSON.stringify({
          type: "SELECTED_ROUTE",
          alertId,
          routeIndex: bestIndex,
          distance,
          duration,
          routeCoordinates: coords
        }));
      }
    });

    map.fitBounds(routeLines[alertId][bestIndex].getBounds());
  });
}
    
function rotateResponderMarker(alertId, heading) {
  const marker = responderMarkers[alertId];
  if (!marker || !marker._icon) return;

  marker._icon.style.transform = `rotate(${heading}deg)`;
  marker._icon.style.transformOrigin = 'center center';
}


window.addEventListener("deviceorientation", handleOrientation);
window.addEventListener("deviceorientationabsolute", handleOrientation);

function handleOrientation(event) {
    if (!activeAssignment) return; // only rotate the active responder

    let heading;

    if (event.webkitCompassHeading !== undefined) {
        heading = event.webkitCompassHeading; // iOS
    } else if (event.alpha !== null) {
        heading = 360 - event.alpha;           // Android & others
    } else {
        heading = 0;
    }

    // Rotate the marker using the new function
    rotateResponderMarker(activeAssignment.alertId, heading);
}








// Watch device location 
navigator.geolocation.watchPosition(
  (pos) => {
    if (!activeAssignment) return;

const lat = pos.coords.latitude;
const lng = pos.coords.longitude;

// Update marker position
responderMarkers[activeAssignment.alertId].setLatLng([lat, lng]);

// Optionally, you can also send location to the server
ws.send(JSON.stringify({
  type: "LOCATION_UPDATE",
  alertId: activeAssignment.alertId,
  latitude: lat,
  longitude: lng
}));

    },
  (err) => console.error("Geolocation error:", err),
  { enableHighAccuracy: true, maximumAge: 1000 }
);


// REMOVE ALERT
function removeAlert(id){
  if(emergencyMarkers[id]) map.removeLayer(emergencyMarkers[id]);
  if(routeLines[id]) map.removeLayer(routeLines[id]);
  delete routeLines[id];
}
</script>
</body>
</html>
