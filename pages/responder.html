<!DOCTYPE html>
<html>
<head>
  <title>Emergency Response Dashboard</title>
  <meta charset="UTF-8" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <style>
    
 * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box; 
      font-family: "Poppins",sans-serif;
    }
  
    h2 { 
      text-align: center; 
  
      padding: 0.5em;
      background-color: whitesmoke;
    }

     
    
    #map { 
      height: 400px; 
      margin-bottom: 10px; 
    }
    table { 
      width: 100%; 
      border-collapse: collapse; 
    }
    
    .table {
      padding: 0.5em;
    }
    th,td { 
      border: 1px solid #ccc; 
      padding: 6px; 
      text-align: center; 
    }
    button { 
      font-size: 1.1rem;
      padding: 5px 8px; 
      border: none; 
      border-radius: 4px; 
      cursor: pointer; 
      width: 20%;
      background-color: magenta;
      color: white;
    }
    .accept { 
      background: green; 
      color: white;
    }
    .reject { 
      background: red; 
      color: white;
    }
    .resolve { 
      background: purple; 
      color: white;
    }
    .routeOption { 
      background: #007bff; 
      color: white; 
      margin: 2px;
    }
    #routeInfo { 
      margin-top: 8px; 
      font-size: 14px; 
    }
    #debugPanel {
      position:fixed; bottom:0; left:0; width:100%;
      max-height:150px; overflow-y:auto;
      background:rgba(0,0,0,0.8); color:#0f0;
      font-size:11px; padding:5px; font-family:monospace;
    }
.routeCard {
  border: 1px solid #ddd;
  padding: 10px;
  margin-bottom: 8px;
  border-radius: 6px;
  background: #fff;
}

.routeCard span {
  display: inline-block;
  margin-right: 10px;
  font-size: 14px;
}

.routeCard button {
  float: right;
  padding: 4px 10px;
  border: none;
  background: #1976d2;
  color: white;
  border-radius: 4px;
  cursor: pointer;
}

.routeCard.selected {
  border: 2px solid #1976d2;
  background: #e3f2fd;
}
  </style>
</head>
<body>

<h2>Emergency Response Dashboard</h2>
<div class="table">
<table>
<thead>
<tr><th>Name</th><th>Phone</th><th>Message</th><th>Action</th><th>waiting</th></tr>
</thead>
<tbody id="rows"></tbody>
</table>
</div>
<div id="routeInfo">
</div>
<div id="map"></div>

<div id="debugPanel"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
// DEBUG LOG
function log(msg){
  const panel = document.getElementById("debugPanel");
  const time = new Date().toLocaleTimeString();
  panel.innerText += `[${time}] ${typeof msg==="object"?JSON.stringify(msg):msg}\n`;
  panel.scrollTop = panel.scrollHeight;
}


if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("/swr.js")
    .then(() => log("SW registered"))
    .catch(err => log("SW registration failed: " + err));
}

// CONFIG
const WS_URL = "wss://campus-emergency-server.onrender.com";
const role = localStorage.getItem("role");
let ws;
let activeAssignment = null;


// MAP
const map = L.map("map").setView([0,0],2);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(map);

const emergencyMarkers = {};
const responderMarkers = {};
const routeLines = {};
let currentWatchId = null;


// RESPONDER ICON
const responderIcon = L.divIcon({
  html:`<div id="responderArrow" style="
        width:30px;height:30px;
        background:url('https://cdn-icons-png.flaticon.com/512/684/684908.png') no-repeat center;
        background-size:contain;
        transform:rotate(0deg);"></div>`,
  className:"",
  iconSize:[30,30]
});


// CONNECT WEBSOCKET
function connectWS(){
  ws = new WebSocket(WS_URL);

  ws.onopen = () => {
    const token = localStorage.getItem("token");
    if(token) ws.send(JSON.stringify({ token }));
    log("WS Connected");
    log("Role: " + role);
  };

  ws.onclose = ()=>{
    log("WS Reconnecting...");
    setTimeout(connectWS,3000);
  };

  ws.onmessage = handleWSMessage;
}
connectWS();

// HANDLE MESSAGES
function handleWSMessage(e){
  const msg = JSON.parse(e.data);
  log(msg);

  // After authentication → send initial location
  if (msg.type === "AUTH_SUCCESS") {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(pos => {
        ws.send(JSON.stringify({
          type: "LOCATION_UPDATE",
          latitude: pos.coords.latitude,
          longitude: pos.coords.longitude
        }));
      }, console.error, { enableHighAccuracy: true });
    }
  }

  // Only responders handle assignments
  if(msg.type === "EMERGENCY_ASSIGNMENT" && role !== "user"){
    showAssignmentUI(msg);
    log("Emergency Assignment received " + msg);
  }

  // If victim gets responder accepted
  if(msg.type === "RESPONDER_ACCEPTED"){
    log("Responder accepted alert " + msg.alertId);
  }

  if(msg.type === "ALERT_RESOLVED"){
    removeAlert(msg.alertId);
  }
}


// SHOW ASSIGNMENT UI
function showAssignmentUI(msg){

  activeAssignment = msg;

  // Add marker for emergency
  if(!emergencyMarkers[msg.alertId]){
    emergencyMarkers[msg.alertId] =
      L.marker([msg.latitude,msg.longitude]).addTo(map);
  }

  const row = document.createElement("tr");
  row.innerHTML = `
    <td>${msg.name || "Unknown"}</td>
    <td>${msg.phone || "Unknown"}</td>
    <td>${msg.message}</td>
    <td class="status">
      <button onclick="respondToAssignment(${msg.alertId}, true)">Accept</button>
      <button onclick="respondToAssignment(${msg.alertId}, false)">Reject</button>
    </td>
  `;

  document.getElementById("rows").appendChild(row);
}

// RESPOND TO ASSIGNMENT
function respondToAssignment(alertId, accept){
  const status = document.querySelector(".status");
  ws.send(JSON.stringify({
    type:"RESPONDER_RESPONSE",
    alertId,
    accept
  }));

  if(accept && activeAssignment){
 
  status.innerText = "Accepted";
    startNavigation(
      alertId,
      activeAssignment.latitude,
      activeAssignment.longitude
    );
  } else {
 status.innerText = "rejected";
  }
}


// START NAVIGATION
function startNavigation(alertId, destLat, destLng){

  if(currentWatchId) navigator.geolocation.clearWatch(currentWatchId);

  if(!responderMarkers[alertId]){
    responderMarkers[alertId] =
      L.marker([0,0],{icon:responderIcon}).addTo(map);
  }

  navigator.geolocation.getCurrentPosition(pos => {

  const startLat = pos.coords.latitude;
  const startLng = pos.coords.longitude;

  responderMarkers[alertId].setLatLng([startLat,startLng]);

  fetchRoutes(alertId,startLat,startLng,destLat,destLng);

});


  currentWatchId = navigator.geolocation.watchPosition(pos=>{

    const startLat = pos.coords.latitude;
    const startLng = pos.coords.longitude;

    responderMarkers[alertId].setLatLng([startLat,startLng]);

    updateHeading(startLat,startLng,destLat,destLng);

    ws.send(JSON.stringify({
      type:"LOCATION_UPDATE",
      alertId,
      latitude:startLat,
      longitude:startLng
    }));

  }, console.error, { enableHighAccuracy:true });
}


function fetchRoutes(alertId, sLat, sLng, dLat, dLng) {

  fetch(`https://router.project-osrm.org/route/v1/driving/${sLng},${sLat};${dLng},${dLat}?alternatives=true&overview=full&geometries=geojson`)
  .then(r => r.json())
  .then(data => {

    if (!data.routes || data.routes.length === 0) return;

    const routeDiv = document.getElementById("routeInfo");
    routeDiv.innerHTML = "";

    // Clear old routes
    if (!routeLines[alertId]) routeLines[alertId] = [];
    routeLines[alertId].forEach(line => map.removeLayer(line));
    routeLines[alertId] = [];

    const colors = ["blue", "green", "red", "orange", "purple"];

    // Find best route (shortest distance + shortest duration)
    let bestIndex = 0;
    let bestScore = Infinity;

    data.routes.forEach((route, index) => {
      const score = route.distance + route.duration;
      if (score < bestScore) {
        bestScore = score;
        bestIndex = index;
      }
    });

    data.routes.forEach((route, index) => {

      const coords = route.geometry.coordinates.map(c => [c[1], c[0]]);
      const distance = (route.distance / 1000).toFixed(2);
      const duration = (route.duration / 60).toFixed(1);

      // Draw ALL routes
      const polyline = L.polyline(coords, {
        color: colors[index % colors.length],
        weight: index === bestIndex ? 6 : 4,
        opacity: index === bestIndex ? 1 : 0.6
      }).addTo(map);

      routeLines[alertId].push(polyline);

      // Create route card
      const card = document.createElement("div");
      card.className = "routeCard";

      const routeName = document.createElement("h4");
      routeName.innerText = `Route ${String.fromCharCode(65 + index)}`;

      const distanceSpan = document.createElement("span");
      distanceSpan.innerText = `Distance: ${distance} km`;

      const durationSpan = document.createElement("span");
      durationSpan.innerText = `Duration: ${duration} min`;

      const btn = document.createElement("button");
      btn.innerText = index === bestIndex ? "Preferred" : "Use";

      if (index === bestIndex) {
        card.classList.add("selected");
      }

      btn.onclick = () => {

        // Update UI highlight
        document.querySelectorAll(".routeCard").forEach(c => {
          c.classList.remove("selected");
          c.querySelector("button").innerText = "Use";
        });

        card.classList.add("selected");
        btn.innerText = "Selected";

        // Highlight selected route
        routeLines[alertId].forEach((line, i) => {
          line.setStyle({
            weight: i === index ? 6 : 4,
            opacity: i === index ? 1 : 0.6
          });
        });

        map.fitBounds(polyline.getBounds());

        // Send FULL route coordinates to server
        ws.send(JSON.stringify({
          type: "SELECTED_ROUTE",
          alertId,
          routeIndex: index,
          distance,
          duration,
          routeCoordinates: coords
        }));
      };

      card.appendChild(routeName);
      card.appendChild(distanceSpan);
      card.appendChild(document.createElement("br"));
      card.appendChild(durationSpan);
      card.appendChild(document.createElement("br"));
      card.appendChild(btn);

      routeDiv.appendChild(card);

      // AUTO SEND BEST ROUTE TO SERVER
      if (index === bestIndex) {
        ws.send(JSON.stringify({
          type: "SELECTED_ROUTE",
          alertId,
          routeIndex: bestIndex,
          distance,
          duration,
          routeCoordinates: coords
        }));
      }
    });

    map.fitBounds(routeLines[alertId][bestIndex].getBounds());
  });
}
    


// Helpers
const toRad = deg => deg * Math.PI / 180;
const toDeg = rad => rad * 180 / Math.PI;



function updateHeading(currentLat, currentLng, destLat, destLng) {
  const arrow = document.getElementById("responderArrow");
  if (!arrow) return;

  // Calculate bearing to destination
  const φ1 = toRad(currentLat);
  const φ2 = toRad(destLat);
  const Δλ = toRad(destLng - currentLng);

  const y = Math.sin(Δλ) * Math.cos(φ2);
  const x = Math.cos(φ1) * Math.sin(φ2) -
            Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);

  let bearing = (toDeg(Math.atan2(y, x)) + 360) % 360;

  // Get device heading if available
  const deviceHeading = arrow._deviceHeading || 0;

  // Compute rotation relative to device orientation
  let rotation = (bearing - deviceHeading + 360) % 360;

  // Smooth rotation using previous rotation
  const currentRotation = arrow._currentRotation || 0;
  let delta = rotation - currentRotation;
  if (delta > 180) delta -= 360;
  if (delta < -180) delta += 360;

  const newRotation = currentRotation + delta;
  arrow._currentRotation = newRotation;

  // Apply rotation
  arrow.style.transition = "transform 0.2s ease-out";
  arrow.style.transform = `rotate(${newRotation}deg)`;
}

// Device orientation listener
window.addEventListener("deviceorientation", (event) => {
  const arrow = document.getElementById("responderArrow");
  if (!arrow) return;

  let deviceHeading = event.alpha;

  // iOS adjustment
  if (typeof event.webkitCompassHeading !== "undefined") {
    deviceHeading = event.webkitCompassHeading;
  } else if (event.absolute === true) {
    // Android adjustment
    deviceHeading = 360 - deviceHeading;
  }

  arrow._deviceHeading = deviceHeading;
});

// watch device location
navigator.geolocation.watchPosition(
  (pos) => {
    const arrow = document.getElementById("responderArrow");
    if (!arrow) return;

    // Store latest location
    arrow._currentLat = pos.coords.latitude;
    arrow._currentLng = pos.coords.longitude;

    // If you already know destination, call updateHeading automatically
    if (arrow._destLat != null && arrow._destLng != null) {
      updateHeading(
        arrow._currentLat,
        arrow._currentLng,
        arrow._destLat,
        arrow._destLng
      );
    }
  },
  (err) => console.error("Geolocation error:", err),
  { enableHighAccuracy: true, maximumAge: 1000 }
);

// Initialize destination
function setDestination(lat, lng) {
  const arrow = document.getElementById("responderArrow");
  if (!arrow) return;
  arrow._destLat = lat;
  arrow._destLng = lng;

  // If location already known, immediately update heading
  if (arrow._currentLat != null && arrow._currentLng != null) {
    updateHeading(arrow._currentLat, arrow._currentLng, lat, lng);
  }
}


// REMOVE ALERT
function removeAlert(id){
  if(emergencyMarkers[id]) map.removeLayer(emergencyMarkers[id]);
  if(routeLines[id]) map.removeLayer(routeLines[id]);
  delete routeLines[id];
}
</script>
</body>
</html>
