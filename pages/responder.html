<!DOCTYPE html>
<html>
<head>
  <title>Emergency Response Dashboard</title>
  <meta charset="UTF-8" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <style>
    
 * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box; 
      font-family: "Poppins",sans-serif;
    }
  
    h2 { 
      text-align: center; 
  
      padding: 0.5em;
      background-color: whitesmoke;
    }

     
    
    #map { 
      height: 400px; 
      margin-bottom: 10px; 
    }
    table { 
      width: 100%; 
      border-collapse: collapse; 
    }
    
    .table {
      padding: 0.5em;
    }
    th,td { 
      border: 1px solid #ccc; 
      padding: 6px; 
      text-align: center; 
    }
    button { 
      font-size: 1.1rem;
      padding: 5px 8px; 
      border: none; 
      border-radius: 4px; 
      cursor: pointer; 
      width: 20%;
      background-color: magenta;
      color: white;
    }
    .accept { 
      background: green; 
      color: white;
    }
    .reject { 
      background: red; 
      color: white;
    }
    .resolve { 
      background: purple; 
      color: white;
    }
    .routeOption { 
      background: #007bff; 
      color: white; 
      margin: 2px;
    }
    #routeInfo { 
      margin-top: 8px; 
      font-size: 14px; 
    }
    #debugPanel {
      position:fixed; bottom:0; left:0; width:100%;
      max-height:150px; overflow-y:auto;
      background:rgba(0,0,0,0.8); color:#0f0;
      font-size:11px; padding:5px; font-family:monospace;
    }
.routeCard {
  border: 1px solid #ddd;
  padding: 10px;
  margin-bottom: 8px;
  border-radius: 6px;
  background: #fff;
}

.routeCard span {
  display: inline-block;
  margin-right: 10px;
  font-size: 14px;
}

.routeCard button {
  float: right;
  padding: 4px 10px;
  border: none;
  background: #1976d2;
  color: white;
  border-radius: 4px;
  cursor: pointer;
}

.routeCard.selected {
  border: 2px solid #1976d2;
  background: #e3f2fd;
}
  </style>
</head>
<body>

<h2>Emergency Response Dashboard</h2>
<div class="table">
<table>
<thead>
<tr><th>Name</th><th>Phone</th><th>Message</th><th>Action</th><th>waiting</th></tr>
</thead>
<tbody id="rows"></tbody>
</table>
</div>
<div id="routeInfo">
</div>
<div id="map"></div>

<div id="debugPanel"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
// --- UTILS & LOGGING ---
function log(msg) {
  const panel = document.getElementById("debugPanel");
  const time = new Date().toLocaleTimeString();
  panel.innerText += `[${time}] ${typeof msg === "object" ? JSON.stringify(msg) : msg}\n`;
  panel.scrollTop = panel.scrollHeight;
}

// --- CONFIG & STATE ---
const WS_URL = "wss://campus-emergency-server.onrender.com";
const role = localStorage.getItem("role");
let ws, activeAssignment = null;
const emergencyMarkers = {}, responderMarkers = {}, routeLines = {};
let currentWatchId = null;

// --- MAP SETUP ---
const map = L.map("map").setView([0, 0], 2);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(map);

const responderIcon = L.icon({
  iconUrl: 'https://cdn-icons-png.flaticon.com/512/684/684908.png', // Ensure this is a top-down arrow
  iconSize: [40, 40],
  iconAnchor: [20, 20]
});

// --- MATH: BEARING & INTERPOLATION ---
// Calculates the angle between two coordinates
function getBearing(lat1, lon1, lat2, lon2) {
  const y = Math.sin((lon2 - lon1) * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180);
  const x = Math.cos(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180) -
    Math.sin(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.cos((lon2 - lon1) * Math.PI / 180);
  return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
}

// --- SMOOTH MOVEMENT ENGINE ---
let lastCoords = null;
let animationFrame = null;

function animateMarker(marker, startPos, endPos, duration = 1000) {
  const startTime = performance.now();
  const bearing = getBearing(startPos[0], startPos[1], endPos[0], endPos[1]);

  if (animationFrame) cancelAnimationFrame(animationFrame);

  function step(now) {
    const elapsed = now - startTime;
    const progress = Math.min(elapsed / duration, 1);

    // Ease-out progress for smoother stops
    const easedProgress = 1 - Math.pow(1 - progress, 2);

    const lat = startPos[0] + (endPos[0] - startPos[0]) * easedProgress;
    const lng = startPos[1] + (endPos[1] - startPos[1]) * easedProgress;

    marker.setLatLng([lat, lng]);
    
    // Apply rotation safely without breaking Leaflet's internal translation
    if (marker._icon) {
        const transform = marker._icon.style.transform;
        // Clean existing rotation to prevent stacking
        const baseTransform = transform.replace(/rotate\([^)]+\)/g, "");
        marker._icon.style.transform = `${baseTransform} rotate(${bearing}deg)`;
    }

    if (progress < 1) {
      animationFrame = requestAnimationFrame(step);
    }
  }
  animationFrame = requestAnimationFrame(step);
}

// --- WEBSOCKETS ---
function connectWS() {
  ws = new WebSocket(WS_URL);
  ws.onopen = () => {
    const token = localStorage.getItem("token");
    if (token) ws.send(JSON.stringify({ token }));
    log("WS Connected. Role: " + role);
  };
  ws.onclose = () => setTimeout(connectWS, 3000);
  ws.onmessage = (e) => {
    const msg = JSON.parse(e.data);
    if (msg.type === "AUTH_SUCCESS") requestInitialLocation();
    if (msg.type === "EMERGENCY_ASSIGNMENT" && role !== "user") showAssignmentUI(msg);
    if (msg.type === "ALERT_RESOLVED") removeAlert(msg.alertId);
  };
}

function requestInitialLocation() {
  navigator.geolocation.getCurrentPosition(pos => {
    ws.send(JSON.stringify({
      type: "LOCATION_UPDATE",
      latitude: pos.coords.latitude,
      longitude: pos.coords.longitude
    }));
  }, null, { enableHighAccuracy: true });
}

// --- UI & NAVIGATION ---
function showAssignmentUI(msg) {
  activeAssignment = msg;
  if (!emergencyMarkers[msg.alertId]) {
    emergencyMarkers[msg.alertId] = L.marker([msg.latitude, msg.longitude]).addTo(map);
  }
  const row = document.createElement("tr");
  row.innerHTML = `
    <td>${msg.name || "User"}</td>
    <td>${msg.message}</td>
    <td id="status-${msg.alertId}">
      <button onclick="respondToAssignment(${msg.alertId}, true)">Accept</button>
    </td>
  `;
  document.getElementById("rows").appendChild(row);
}

function respondToAssignment(alertId, accept) {
  ws.send(JSON.stringify({ type: "RESPONDER_RESPONSE", alertId, accept }));
  if (accept) {
    document.getElementById(`status-${alertId}`).innerText = "Accepted";
    startNavigation(alertId, activeAssignment.latitude, activeAssignment.longitude);
  }
}

function startNavigation(alertId, destLat, destLng) {
  if (currentWatchId) navigator.geolocation.clearWatch(currentWatchId);

  if (!responderMarkers[alertId]) {
    responderMarkers[alertId] = L.marker([0, 0], { icon: responderIcon }).addTo(map);
  }

  // First fetch to draw the path
  navigator.geolocation.getCurrentPosition(pos => {
    const start = [pos.coords.latitude, pos.coords.longitude];
    lastCoords = start;
    responderMarkers[alertId].setLatLng(start);
    fetchRoutes(alertId, start[0], start[1], destLat, destLng);
  });

  // Continuous watch for movement
  currentWatchId = navigator.geolocation.watchPosition(pos => {
    const newCoords = [pos.coords.latitude, pos.coords.longitude];
    
    if (lastCoords) {
      animateMarker(responderMarkers[alertId], lastCoords, newCoords, 1000);
    }
    
    lastCoords = newCoords;

    ws.send(JSON.stringify({
      type: "LOCATION_UPDATE",
      alertId,
      latitude: newCoords[0],
      longitude: newCoords[1]
    }));
  }, console.error, { 
    enableHighAccuracy: true,
    maximumAge: 0,
    timeout: 5000 
  });
}

// --- ROUTING (OSRM) ---
function fetchRoutes(alertId, sLat, sLng, dLat, dLng) {
  fetch(`https://router.project-osrm.org/route/v1/driving/${sLng},${sLat};${dLng},${dLat}?overview=full&geometries=geojson`)
    .then(r => r.json())
    .then(data => {
      if (!data.routes?.length) return;
      
      if (routeLines[alertId]) routeLines[alertId].forEach(l => map.removeLayer(l));
      routeLines[alertId] = [];

      const route = data.routes[0];
      const coords = route.geometry.coordinates.map(c => [c[1], c[0]]);
      const polyline = L.polyline(coords, { color: 'blue', weight: 6 }).addTo(map);
      routeLines[alertId].push(polyline);
      map.fitBounds(polyline.getBounds(), { padding: [50, 50] });
    });
}

function removeAlert(id) {
  if (emergencyMarkers[id]) map.removeLayer(emergencyMarkers[id]);
  if (routeLines[id]) routeLines[id].forEach(l => map.removeLayer(l));
  if (responderMarkers[id]) map.removeLayer(responderMarkers[id]);
  delete routeLines[id];
}

connectWS();

</script>
</body>
</html>
