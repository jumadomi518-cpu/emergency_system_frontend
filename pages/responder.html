<!DOCTYPE html>
<html>
<head>
  <title>Emergency Response Dashboard</title>
  <meta charset="UTF-8" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <style>
    
 * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box; 
      font-family: "Poppins",sans-serif;
    }
  
    h2 { 
      text-align: center; 
  
      padding: 0.5em;
      background-color: whitesmoke;
    }

     
    
    #map { 
      height: 400px; 
      margin-bottom: 10px; 
    }
    table { 
      width: 100%; 
      border-collapse: collapse; 
    }
    
    .table {
      padding: 0.5em;
    }
    th,td { 
      border: 1px solid #ccc; 
      padding: 6px; 
      text-align: center; 
    }
    button { 
      font-size: 1.1rem;
      padding: 5px 8px; 
      border: none; 
      border-radius: 4px; 
      cursor: pointer; 
      width: 20%;
      background-color: magenta;
      color: white;
    }
    .accept { 
      background: green; 
      color: white;
    }
    .reject { 
      background: red; 
      color: white;
    }
    .resolve { 
      background: purple; 
      color: white;
    }
    .routeOption { 
      background: #007bff; 
      color: white; 
      margin: 2px;
    }
    #routeInfo { 
      margin-top: 8px; 
      font-size: 14px; 
    }
    #debugPanel {
      position:fixed; bottom:0; left:0; width:100%;
      max-height:150px; overflow-y:auto;
      background:rgba(0,0,0,0.8); color:#0f0;
      font-size:11px; padding:5px; font-family:monospace;
    }
.routeCard {
  font-size: 1.2rem;
  display: flex;
  justify-content: space-between;
}

.routeCard span {
  display: inline-block;
  margin-right: 10px;
  font-size: 14px;
}

.routeCard button {
  padding: 4px 10px;
  border: none;
  background: #1976d2;
  color: white;
  border-radius: 4px;
  cursor: pointer;
}

.routeCard.selected {
  border: 2px solid #1976d2;
  background: #e3f2fd;
}
  </style>
</head>
<body>

<h2>Emergency Response Dashboard</h2>
<div class="table">
<table>
<thead>
<tr><th>Name</th><th>Phone</th><th>Message</th><th>Action</th><th>waiting</th></tr>
</thead>
<tbody id="rows"></tbody>
</table>
</div>
<div id="routeInfo">
</div>
<div id="map"></div>

<div id="debugPanel"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
function log(msg) {
  const panel = document.getElementById("debugPanel");
  const time = new Date().toLocaleTimeString();
  panel.innerText += `[${time}] ${typeof msg === "object" ? JSON.stringify(msg) : msg}\n`;
  panel.scrollTop = panel.scrollHeight;
}

// CONFIG & STATE 
const WS_URL = "wss://campus-emergency-server.onrender.com";
const role = localStorage.getItem("role");
let ws, activeAssignment = null;
const emergencyMarkers = {}, responderMarkers = {}, routeLines = {};
const animationFrames = {};
let currentWatchId = null;

// --- MAP SETUP ---
const map = L.map("map").setView([0, 0], 2);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(map);

// SMOOTH MOVEMENT
function animateMarker(marker, startPos, endPos, duration = 1000) {
  const startTime = performance.now();

  if (animationFrames[marker._leaflet_id]) cancelAnimationFrame(animationFrames[marker._leaflet_id]);

  function step(now) {
    const elapsed = now - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const eased = 1 - Math.pow(1 - progress, 2);

    const lat = startPos[0] + (endPos[0] - startPos[0]) * eased;
    const lng = startPos[1] + (endPos[1] - startPos[1]) * eased;
    marker.setLatLng([lat, lng]);

    if (progress < 1) {
      animationFrames[marker._leaflet_id] = requestAnimationFrame(step);
    } else {
      delete animationFrames[marker._leaflet_id];
    }
  }

  animationFrames[marker._leaflet_id] = requestAnimationFrame(step);
}

// WEBSOCKET
function connectWS() {
  ws = new WebSocket(WS_URL);

  ws.onopen = () => {
    const token = localStorage.getItem("token");
    if (token) ws.send(JSON.stringify({ token }));
    log("WS Connected. Role: " + role);
  };

  ws.onclose = () => setTimeout(connectWS, 3000);

  ws.onmessage = (e) => {
    const msg = JSON.parse(e.data);

    switch (msg.type) {
      case "AUTH_SUCCESS":
        requestInitialLocation();
        break;
      case "EMERGENCY_ASSIGNMENT":
        if (role !== "user") showAssignmentUI(msg);
        break;
      case "ALERT_RESOLVED":
        removeAlert(msg.alertId);
        break;
    }
  };
}

// FETCH ROUTES 
function fetchRoutes(alertId, sLat, sLng, dLat, dLng) {
  fetch(`https://router.project-osrm.org/route/v1/driving/${sLng},${sLat};${dLng},${dLat}?alternatives=true&overview=full&geometries=geojson`)
    .then(r => r.json())
    .then(data => {
      if (!data.routes || data.routes.length === 0) return;

      const routeDiv = document.getElementById("routeInfo");
      routeDiv.innerHTML = "";

      if (!routeLines[alertId]) routeLines[alertId] = [];
      routeLines[alertId].forEach(line => map.removeLayer(line));
      routeLines[alertId] = [];

      const colors = ["blue", "green", "red", "orange", "purple"];
      let bestIndex = 0, bestScore = Infinity;

      data.routes.forEach((route, index) => {
        const score = route.distance + route.duration;
        if (score < bestScore) {
          bestScore = score;
          bestIndex = index;
        }
      });

      data.routes.forEach((route, index) => {
        const coords = route.geometry.coordinates.map(c => [c[1], c[0]]);
        const distance = (route.distance / 1000).toFixed(2);
        const duration = (route.duration / 60).toFixed(1);

        const polyline = L.polyline(coords, {
          color: colors[index % colors.length],
          weight: index === bestIndex ? 6 : 4,
          opacity: index === bestIndex ? 1 : 0.6
        }).addTo(map);

        routeLines[alertId].push(polyline);

        const card = document.createElement("div");
        card.className = "routeCard";

        const routeName = document.createElement("h4");
        routeName.innerText = `Route ${String.fromCharCode(65 + index)}`;

        const distanceSpan = document.createElement("span");
        distanceSpan.innerText = `Distance: ${distance} km`;

        const durationSpan = document.createElement("span");
        durationSpan.innerText = `Duration: ${duration} min`;

        const btn = document.createElement("button");
        btn.innerText = index === bestIndex ? "Preferred" : "Use";

        if (index === bestIndex) card.classList.add("selected");

        btn.onclick = () => {
          document.querySelectorAll(".routeCard").forEach(c => {
            c.classList.remove("selected");
            c.querySelector("button").innerText = "Use";
          });

          card.classList.add("selected");
          btn.innerText = "Preferred";

          routeLines[alertId].forEach((line, i) => {
            line.setStyle({ weight: i === index ? 6 : 4, opacity: i === index ? 1 : 0.6 });
          });

          map.fitBounds(polyline.getBounds());

          ws.send(JSON.stringify({
            type: "SELECTED_ROUTE",
            alertId,
            routeIndex: index,
            distance,
            duration,
            routeCoordinates: coords
          }));
        };

        card.appendChild(routeName);
        card.appendChild(distanceSpan);
        card.appendChild(document.createElement("br"));
        card.appendChild(durationSpan);
        card.appendChild(document.createElement("br"));
        card.appendChild(btn);

        routeDiv.appendChild(card);

        // Auto send best route
        if (index === bestIndex) {
          ws.send(JSON.stringify({
            type: "SELECTED_ROUTE",
            alertId,
            routeIndex: bestIndex,
            distance,
            duration,
            routeCoordinates: coords
          }));
        }
      });

      map.fitBounds(routeLines[alertId][bestIndex].getBounds());
    });
}

//  LOCATION 
function requestInitialLocation() {
  navigator.geolocation.getCurrentPosition(pos => {
    ws.send(JSON.stringify({
      type: "LOCATION_UPDATE",
      latitude: pos.coords.latitude,
      longitude: pos.coords.longitude
    }));
  }, console.error, { enableHighAccuracy: true });
}

// UI & ASSIGNMENT
function showAssignmentUI(msg) {
  activeAssignment = msg;

  if (!emergencyMarkers[msg.alertId]) {
    emergencyMarkers[msg.alertId] = L.circle([msg.latitude, msg.longitude], {
      radius: 10,
      color: 'red',
      fillColor: 'red',
      fillOpacity: 1
    }).addTo(map);
  }

  const row = document.createElement("tr");
  row.innerHTML = `
    <td>${msg.name}</td>
    <td>${msg.phone}</td>
    <td>${msg.message}</td>
    <td id="status-${msg.alertId}">
      <button onclick="respondToAssignment(${msg.alertId}, true)">Accept</button>
      <button onclick="respondToAssignment(${msg.alertId}, false)">Reject</button>
    </td>
  `;
  document.getElementById("rows").appendChild(row);
}


function respondToAssignment(alertId, accept) {
  ws.send(JSON.stringify({ type: "RESPONDER_RESPONSE", alertId, accept }));

  if (accept) {
    document.getElementById(`status-${alertId}`).innerText = "Accepted";
    startNavigation(alertId, activeAssignment.latitude, activeAssignment.longitude);

    // Fetch routes after getting current location
    navigator.geolocation.getCurrentPosition(pos => {
      fetchRoutes(alertId, pos.coords.latitude, pos.coords.longitude,
                  activeAssignment.latitude, activeAssignment.longitude);
    }, console.error, { enableHighAccuracy: true });
  } else {

  document.getElementById(`status-${alertId}`).innerText = "Rejected";
   }
}


// NAVIGATION 
function startNavigation(alertId, destLat, destLng) {
  if (currentWatchId) navigator.geolocation.clearWatch(currentWatchId);

  if (!responderMarkers[alertId]) {
    responderMarkers[alertId] = L.circle([0, 0], {
      radius: 10,
      color: 'blue',
      fillColor: 'blue',
      fillOpacity: 1
    }).addTo(map);
  }

  navigator.geolocation.getCurrentPosition(pos => {
    const start = [pos.coords.latitude, pos.coords.longitude];
    responderMarkers[alertId].setLatLng(start);
    map.setView(start, 15);
  });

  currentWatchId = navigator.geolocation.watchPosition(pos => {
    const newCoords = [pos.coords.latitude, pos.coords.longitude];
    const marker = responderMarkers[alertId];

    if (marker._latlng) {
      animateMarker(marker, [marker._latlng.lat, marker._latlng.lng], newCoords, 1000);
    } else {
      marker.setLatLng(newCoords);
    }

    ws.send(JSON.stringify({
      type: "LOCATION_UPDATE",
      alertId,
      latitude: newCoords[0],
      longitude: newCoords[1]
    }));
  }, console.error, { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 });
}

function removeAlert(id) {
  if (emergencyMarkers[id]) map.removeLayer(emergencyMarkers[id]);
  if (responderMarkers[id]) map.removeLayer(responderMarkers[id]);
  delete responderMarkers[id];
  delete emergencyMarkers[id];
}

connectWS();
</script>
</body>
</html>
