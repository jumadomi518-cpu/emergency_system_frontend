<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title></title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      font-family: "Poppins", sans-serif;
      box-sizing: border-box;
    }
    
    .map {
      margin: 0 0.2em 0.6em 0.6em;
      height: 40vh;
    }
    .timeAncestor {
      font-size: 1.4rem;
      padding: 1em 1em 1em 2em;
      display: flex;
      flex-direction: column;
      border: 2px solid black;
      margin: 0.5em;
      box-shadow: 0 0 4px 0 black;
      
    }
    .waitingContainer {
      display: flex;
      width: 50%;
      justify-content: space-between;
      margin-top: 0.7em;
    }
    
    input {
      font-size: 1.5rem;
      width: 60%;
      margin-right: 1em;
    }
    button {
      font-size: 1.4rem;
      padding: 0.4em;
      border: none;
      background-color: green;
      color: white;
      border-radius: 0.3em;
    }
    
    .view {
      display: flex;
      justify-content: flex-end;
      font-size: 1.3rem;
      padding: 0.9em 0.5em 0.5em 0.5em;
    }
    
    .large {
      border: 2px solid green;
      padding: 0.3em;
      border-radius: 0.4em;
    }
    header {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      padding: 0.2em 0.5em 0.5em 0.5em;
      margin: 0.5em;
      height: auto;
      box-shadow: 0 0 4px 0 black;
    }
    
    .heading {
      display: grid;
      place-items: center;
      height: 10vh;
    }
    h1 {
      margin-top: 0em;
    }
    
    img {
      height: 10vh;

      
    }
    
    .height {
      height: 80vh;
    }
    #etaDisplay {
      font-size: 1.5rem;
      padding: 0.5em;
    }
   button:active {
   background-color: black;
    }
    
  </style>
</head>

<body>
  <header>
    <img src="../assets/1771060588592.png" id="logo" />
    <div class="heading">
<h1>Emergency Response System Traffic View.</h1>
    </div>
  </header>
  <main>
    <div class="view"><p class="large">View large map</p>
      
    </map></p></div>
    <div id="etaDisplay"></div>
       <div id="map" class="map">
      
    </div>
    <div class="timeAncestor">
      <p>Waiting Time</p>
      <div class="waitingContainer">
        <input type="number" max="15" min="1" />
        <button>send</button>
      </div>
    </div>
  </main>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
  
  // GLOBAL VARIABLES
let isAuthenticated = false;
let emergencyMarker = null;
let victimMarker = null;
let responderMarkers = {};
let routeCoordinates = {};
let routeRemainingPolyline = {};
let routeTraveledPolyline = {};

let watchId = null;
let firstUpdate = true;
let mapFollowResponder = true;
const userId = localStorage.getItem("userId");

const etaDisplay = document.getElementById("etaDisplay");

const map = L.map("map").setView([0,0], 13);

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  attribution: "&copy; OpenStreetMap contributors"
}).addTo(map);

const queryString = window.location.search;
const urlParams = new URLSearchParams(queryString);
const alertId = urlParams.get('alertId');

if (!alertId) {
  alert("No alertId provided in URL");
}

const ma = document.getElementById("map");
const view = document.querySelector(".large");
const btn = document.querySelector("button");
const input = document.querySelector("input");

let check = true;
view.onclick = () => {
  ma.classList.toggle("height");
  view.innerText = check ? "View small map." : "View large map.";
  check = !check;
};

function countDown(time) {
  let seconds = Number(time) * 60;
 const t = setInterval(() => {
    seconds = seconds - 1;
    if (seconds === 0) {
      clearInterval(t);
      alert("Waiting time has ended, Emergency responders have started the journey you can view the progress on the map and create way as quick as possible.");
    }
  }, 1000)
  
  
}

const WS_URL = "wss://campus-emergency-server.onrender.com";
const REST_URL = "https://campus-emergency-server.onrender.com/api";

async function subscribePush() {
  try {
    const reg = await navigator.serviceWorker.ready;

    const sub = await reg.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlBase64ToUint8Array(
        "BLWqWGy69vEeRpqjfjM71X3HH9IfF9mDRhaXsqIdysfGLXE0Ur8HjgtyE0VfDK574WK_dbJ7s6uCenB7PmYRbQE"
      )
    });

    await fetch(`${REST_URL}/subscribe`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        userId: localStorage.getItem("userId"),
        subscription: sub
      })
    });

    alert("Push subscription sent to server");

  } catch (err) {
    alert("Push subscription failed: " + err.message);
  }
}



function urlBase64ToUint8Array(base64String) {
  const padding = "=".repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding)
    .replace(/\-/g, "+")
    .replace(/_/g, "/");

  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);

  for (let i = 0; i < rawData.length; ++i)
    outputArray[i] = rawData.charCodeAt(i);

  return outputArray;
}


subscribePush() 

async function selectedRoute(alertId) {
  try {
    const response = await fetch(`${REST_URL}/route_path/${alertId}/${userId}`);
    const data = await response.json();

    if (!data.data || !data.data[0]) {
      console.error("No route data returned from server");
      return;
    }

    const coordsFromResponder = data.data[0].route_path;
    const victimLat = data.data[0].latitude;
    const victimLng = data.data[0].longitude;

    routeCoordinates[alertId] = coordsFromResponder;

    drawFullRoute(alertId);

    const victimLatLng = [victimLat, victimLng];

    if (!victimMarker) {
      victimMarker = L.circleMarker([victimLat, victimLng], {
        radius: 10,
        color: 'red',
        fillColor: 'red',
        fillOpacity: 0.8
      }).addTo(map).bindPopup("Emergency Location");
    } else {
      victimMarker.setLatLng(victimLatLng);
    }

  } catch (error) {
    console.log("An error occurred while fetching route coordinates", error);
  }
}

function drawFullRoute(alertId){
  const coords = routeCoordinates[alertId];
  if (!coords || coords.length === 0) return;

  if (routeRemainingPolyline[alertId])
    map.removeLayer(routeRemainingPolyline[alertId]);

  if (routeTraveledPolyline[alertId])
    map.removeLayer(routeTraveledPolyline[alertId]);

  routeRemainingPolyline[alertId] =
    L.polyline(coords, { color:"blue", weight:5 }).addTo(map);

  routeTraveledPolyline[alertId] =
    L.polyline([], { color:"green", weight:5 }).addTo(map);

  map.fitBounds(routeRemainingPolyline[alertId].getBounds());
}

function updateRouteProgress(alertId, currentLatLng){
  const route = routeCoordinates[alertId];
  if (!route || route.length === 0) return;

  const nearestIdx = route.reduce((closestIdx, point, idx) => {
    const dist = map.distance(point, currentLatLng);
    return dist < map.distance(route[closestIdx], currentLatLng) ? idx : closestIdx;
  }, 0);

  const remaining = route.slice(nearestIdx);
  const traveled = route.slice(0, nearestIdx + 1);

  if (routeRemainingPolyline[alertId])
    routeRemainingPolyline[alertId].setLatLngs(remaining);

  if (routeTraveledPolyline[alertId])
    routeTraveledPolyline[alertId].setLatLngs(traveled);

  const distanceLeft = remaining.reduce((sum, point, idx) => {
    if (idx === 0) return 0;
    return sum + map.distance(remaining[idx - 1], point);
  }, 0);

  const avgSpeedKmh = 40;
  const speedMps = (avgSpeedKmh * 1000) / 3600;
  const etaSeconds = Math.round(distanceLeft / speedMps);

  etaDisplay.innerText =
    `ETA: ${Math.floor(etaSeconds/60)} min ${etaSeconds%60} sec
     | Distance left: ${(distanceLeft/1000).toFixed(2)} km`;
}

function smoothMoveMarker(marker, newLatLng, duration = 800) {
  const startLatLng = marker.getLatLng();
  const endLatLng = L.latLng(newLatLng);
  const startTime = performance.now();

  function animate(currentTime) {
    const elapsed = currentTime - startTime;
    const progress = Math.min(elapsed / duration, 1);

    const ease = progress < 0.5
      ? 2 * progress * progress
      : 1 - Math.pow(-2 * progress + 2, 2) / 2;

    const lat = startLatLng.lat + (endLatLng.lat - startLatLng.lat) * ease;
    const lng = startLatLng.lng + (endLatLng.lng - startLatLng.lng) * ease;

    marker.setLatLng([lat, lng]);

    if (progress < 1) requestAnimationFrame(animate);
  }

  requestAnimationFrame(animate);
}

let ws;
function connectWS() {
  ws = new WebSocket(WS_URL);

  ws.onopen = () => {
    const token = localStorage.getItem("token");
    console.log("Connected to WS");
    if (token) ws.send(JSON.stringify({ token }));
  };

  ws.onclose = () => setTimeout(connectWS, 3000);

navigator.geolocation.watchPosition(
    pos => {
      const { latitude, longitude } = pos.coords;
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: "LOCATION_UPDATE",
          latitude,
          longitude
        }));
      }

    },
    err => alert("Location error: " + err.message),
    { enableHighAccuracy: true, maximumAge: 1000, timeout: 10000 })
  
  
    btn.onclick = () => {
      if (input.value === "") { alert("A value required"); return; }
      if (Number(input.value) < 1 || Number(input.value) > 15) {
        alert("Enter a value between 1 and 15"); return;
      }
      if (ws.readyState === WebSocket.OPEN)
        ws.send(JSON.stringify({ type: "WAITING_TIME", time: input.value, alertId }));
        alert("Send successful");
          countDown(input.value);
        input.value = "";
        input.setAttribute("disabled", "true");
        btn.setAttribute("disabled", "true");
      
    };
    

  ws.onmessage = (e) => {
    const msg = JSON.parse(e.data);

    if (msg.type === "RESPONDER_LOCATION_UPDATE") {
      const { responderId, alertId, latitude, longitude } = msg;
      const newLatLng = [latitude, longitude];

      if (!responderMarkers[responderId]) {
        responderMarkers[responderId] = L.marker(newLatLng, {
          icon: L.icon({
            iconUrl: "../assets/emergency.png",
            iconSize: [34,34],
            iconAnchor: [17,34]
          })
        })
        .addTo(map)
        .bindPopup("Emergency Responder");
      } else {
        smoothMoveMarker(responderMarkers[responderId], newLatLng, 800);
      }

      if (mapFollowResponder) {
  map.setView(newLatLng, map.getZoom(), { animate: false });
}

      if (routeCoordinates[alertId])
        updateRouteProgress(alertId, newLatLng);
    }
  };
}

let trafficMarker = null;

function startTrafficLocation() {
  if (!navigator.geolocation) {
    console.warn("Geolocation not supported in this browser");
    return;
  }

  watchId = navigator.geolocation.watchPosition(
    (pos) => {
      const { latitude, longitude } = pos.coords;
      const latLng = [latitude, longitude];

      if (!trafficMarker) {
        trafficMarker = L.marker(latLng)
        .addTo(map)
        .bindPopup(" Your Location")
        .openPopup();
      } else {
        smoothMoveMarker(trafficMarker, latLng, 800);
      }
    },
    (err) => {
      console.error("Error getting traffic location:", err);
    },
    { enableHighAccuracy: true, maximumAge: 1000, timeout: 5000 }
  );
}

window.addEventListener("beforeunload", () => {
  if (watchId) navigator.geolocation.clearWatch(watchId);
});

startTrafficLocation();
selectedRoute(alertId);
connectWS();
  


  </script> 
</body>

</html>
